---
title: "ShengweiWu_BitcoinPrice_Forecast"
output:
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 
```{r 0.data pre-process}
#use the same working folder of dataset as the source file

setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

##install packages if not installed and load packages
requiredPackages <- c("SnowballC", "ggplot2", "tseries", "gridExtra","forecast","dplyr","Quandl")


ipak <- function(pkg){
        new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
        if (length(new.pkg))
                install.packages(new.pkg, dependencies = TRUE)
        sapply(pkg, require, character.only = TRUE)
}

# ## the lastest Data for bitcoin


mydata = Quandl("BCHAIN/MKPRU")
# View(mydata)
## clean and transform data for the whole data
btc <- mydata %>% na.omit()
btc <- price[nrow(btc):1,]
names(btc) <- c("Date","Price")
btc$Date <- as.Date(btc$Date)


## when I was doing the project, the time is aroud April 1, 2019, so I just use this data
btc <- btc %>% filter(Date <='2019-04-01')




## clean data

#View(btc)


p1 <- ggplot(btc,aes(Date, Price)) +
  geom_line()+
  labs(title = "the whole data")+
  theme_classic()
p2 <- ggplot(btc,aes(Date, Price))+
  geom_line()+
  scale_x_date(limits = as.Date(c("2017-01-01","2019-04-01")))+
  labs(title = "data after 2017")+
  theme_classic()
grid.arrange(
  p1,
  p2
)

#data after Year 2017
bitcoin <- btc %>% filter(Date >="2017-1-1") %>% select(Price)
bitcoin <- ts(bitcoin,frequency = 365.25,start = c(2017,1,1))



##When compund grouth is not due to inflation, like when data is not measured in currency;when the variables are multiplicatively related
##when you do not need to separate inflation from real growth; when data distribution is positigve highly skewed(log-normally distribution);
##I am not considering the log transformation
####The time plot shows some sudden changes, particularly the big drop in 2018. These changes are due to the WannaCry ransomware attack. Otherwise there is nothing unusual about the time plot and there appears to be no need to do any data adjustments.
```

```{r 1.decompose}
plot(decompose(bitcoin))+
  title(main =" Bitcoin ")

```



```{r 2.1 stationary}



##stationary test
kpss.test(bitcoin,null="Level")
kpss.test(bitcoin,null="Trend")

kptest <- function(series,alpha=0.05){
    suppressWarnings(pval <- kpss.test(series,null="Level")$p.value)
    if(pval>=alpha){
      print("Can't reject Hypothsis that  a null hypothesis with no Level")
    }else{print("The null hypothesis of stationarity around a Level is rejected")}
    suppressWarnings(pval <- kpss.test(series,null="Trend")$p.value)
    if(pval>=alpha){
      print("The null hypothesis of stationarity around a trend is not rejected.")
    }else{print("The null hypothesis of stationarity around a Trend is rejected")}
}
kptest(bitcoin)



```

```{r 2.2 diff stationary}



bitcoin %>% diff() %>% ndiffs()
bitcoin %>% diff() %>% nsdiffs()

##This process of using a sequence of KPSS tests to determine the appropriate number of first differences is carried out by the function
##1 difference



## A similar function for determining whether seasonal differencing is required is nsdiffs(), which uses the measure of seasonal strength introduced in Section 6.7 to determine the appropriate number of seasonal differences required. No seasonal differences are suggested if  Fs <0.64, otherwise one seasonal difference is suggested.
## the result is 0
##no seasonal difference

ts <- diff(bitcoin)
plot.ts(ts,main =" difference of Bitcoin")


```
```{r 2.3}
cbind("Bitcoin" = bitcoin,
      "difference " = diff(bitcoin)) %>%
  autoplot(facets=TRUE) +
    xlab("Year") + ylab("") +
    ggtitle("Bitcoin")
```
```{r 3. acf, pacf}
ggtsdisplay(ts, main ="difference of bitcoin")+
  theme_classic()
```


```{r 4.1 ARIMA}
##because it's not easy for us to figure out the numbers of spikes in the ACF and PACF, we can;t determine the order in ARIMA using the ARIMA(). 
##As a result, I have to use auto.arima() function to do it even if the arima() is more precise than auto.arima() because the auto.arima() does not consider all possible models in its search

# forecast::auto.arima(ts, trace=TRUE,stepwise=TRUE, approximation = FALSE,seasonal=FALSE)
##the best ARIMA model is (1,0,1) with zero mean, AIC=10830.91   AICc=10830.94   BIC=10844.7

#These approximations can be avoided with the argument
#A much larger set of models will be searched if the argument stepwise=FALSE

##use an exhaustive search
forecast::auto.arima(ts, trace=TRUE, stepwise=FALSE,approximation=FALSE,seasonal=FALSE)
##Best model: ARIMA(0,0,5)             with zero mean     , AIC=10822.53   AICc=10822.64   BIC=10850.11
##Four initial models are fitted:A constant is included unless  d = 2, an additional model is also fitted.
##(0,d0,) with a constant




fit <- forecast::auto.arima(ts,stepwise=FALSE,approximation=FALSE,seasonal=FALSE)
fit


```
```{r 4.2. Check residuals}
res <- residuals(fit)
checkresiduals(fit)

##The ACF plot of the residuals from the ARIMA(0,0,5) model shows that all autocorrelations are spartial , indicating that the residuals are behaving not like white noise. A portmanteau test returns a small p-value, also suggesting that the residuals are not white noise.
```
```{r 4.2}
gghistogram(res) + ggtitle("Histogram of residuals")
```


```{r 4.3 forecast}
##forecast next 30 days, ranging from 2019-4-1 to 2019-5-1 for difference
autoplot(forecast(fit, h=90))

```

```{r 4.5}

##The stationarity conditions for the model are that the r complax roots of lie outside the unit circcle
##the invertibility conditions are that the   q complex roots of lie outside the unit cicle
##so we can see whether the model is close to invertibility or stationarity by a plot of the roots in relation to the complex unit circle
##It is easier to plot the inverse roots instead, as they should all lie within the unit circle. This is easily done in R. For the ARIMA(0,0,5) model fitted to the seasonally adjusted electrical equipment index, we obtain Figure 8.16.
autoplot(fit)


```
```{r 5 ETS}
fit.ets <- suppressWarnings( ets(ts))
summary(fit.ets)

```
```{r 5.2}

autoplot(fit.ets)
```
```{r 5.3}
fit.ets %>% forecast(h=90) %>%
  autoplot() +
  ylab("Bitcoin") 
```
```{r 6.compraison}
fets <- function(x, h) {
  forecast(ets(x), h = h)
}
farima <- function(x, h) {
  forecast(auto.arima(x), h=h)
}

e1 <- tsCV(ts, fets, h=30)
# Compute CV errors for ARIMA as e2
e2 <- tsCV(ts, farima, h=30)



# Find MSE of each model class
mean(e1^2, na.rm=TRUE)
#> [1] 165464.7
mean(e2^2, na.rm=TRUE)
#> [1] 152923.9
```



```{r 6.2}


fets <- ts%>% ets() %>% forecast(h = 90)
farima <- ts %>% auto.arima(stepwise=FALSE,approximation=FALSE,seasonal=FALSE) %>% forecast(h = 90)

autoplot(fets)+
  autolayer(farima)+
  xlab("Year") + 
  ggtitle("ETS & AIRMA Forecasts for difference of Bitcoin next 90 days from 2019-04-01 ") +
  guides(colour=guide_legend(title="Forecast"))

```





```{r 6.3 test accuracy}
## the lastest Data for bitcoin

## clean and transform data for testing
# View(mydata)
mydata <- mydata[nrow(mydata):1,]
mydata$Date <- as.Date(mydata$Date)
test <- mydata %>% filter(Date >="2017-01-01")%>% select(Value)
test <- ts(test,frequency = 365.25,start = c(2017,1,1))

 autoplot(fets)+
  autolayer(farima)+
  autolayer(diff(test))+
  xlab("Year") + 
  ggtitle("Testing fot the forecasting next 90 days from 2019-04-01") 

```
```{r}
plot.ts(test)+title(main = 'bitcoin price till now')
```

